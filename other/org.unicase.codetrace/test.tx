/********************************************************************************/
/*										*/
/*		DypatchMain.java						*/
/*										*/
/*	Main program for DYPER patcher						*/
/*										*/
/********************************************************************************/
/*	Copyright 2005 Brown University -- Steven P. Reiss		      */
/*********************************************************************************
 *  Copyright 2005, Brown University, Providence, RI.				 *
 *										 *
 *			  All Rights Reserved					 *
 *										 *
 *  Permission to use, copy, modify, and distribute this software and its	 *
 *  documentation for any purpose other than its incorporation into a		 *
 *  commercial product is hereby granted without fee, provided that the 	 *
 *  above copyright notice appear in all copies and that both that		 *
 *  copyright notice and this permission notice appear in supporting		 *
 *  documentation, and that the name of Brown University not be used in 	 *
 *  advertising or publicity pertaining to distribution of the software 	 *
 *  without specific, written prior permission. 				 *
 *										 *
 *  BROWN UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS		 *
 *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND		 *
 *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL BROWN UNIVERSITY	 *
 *  BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY 	 *
 *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,		 *
 *  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS		 *
 *  ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 	 *
 *  OF THIS SOFTWARE.								 *
 *										 *
 ********************************************************************************/

/* RCS: $Header: /pro/spr_cvs/pro/wadi/javasrc/edu/brown/cs/wadi/dypatch/DypatchMain.java,v 1.8 2008-06-11 22:36:21 spr Exp $ */


/*********************************************************************************
 *
 * $Log: DypatchMain.java,v $
 * Revision 1.8  2008-06-11 22:36:21  spr
 * Clear up the code.
 *
 * Revision 1.7  2008-06-02 22:32:10  spr
 * Clean up paths.
 *
 * Revision 1.6  2008-05-27 22:09:55  spr
 * Fix up paths, add reaction patching modes.
 *
 * Revision 1.5  2007-11-06 00:31:28  spr
 * Fixup message interface.
 *
 * Revision 1.4  2007-09-22 02:52:09  spr
 * Minor clean ups for patching.
 *
 * Revision 1.3  2007-08-10 02:43:37  spr
 * Fixup patching program for dyper.
 *
 * Revision 1.2  2007-05-10 02:28:13  spr
 * Continue adding patching capabilities.
 *
 * Revision 1.1  2007-05-05 03:22:31  spr
 * Dyper patcher initial version.
 *
 *
 ********************************************************************************/



package edu.brown.cs.wadi.dypatch;


import edu.brown.cs.ivy.cinder.*;
import edu.brown.cs.ivy.mint.*;
import edu.brown.cs.ivy.xml.IvyXml;
import edu.brown.cs.ivy.xml.IvyXmlWriter;

import com.ibm.jikesbt.BT_Class;

import org.w3c.dom.Element;

import java.io.*;
import java.util.*;



public class DypatchMain implements DypatchConstants, MintConstants, CinderFilter {





/********************************************************************************/
/*										*/
/*	Main program								*/
/*										*/
/********************************************************************************/

public static void main(String [] args)
{
   DypatchMain dm = new DypatchMain(args);

   dm.process();

   if (test_flag) dm.test();
}




/********************************************************************************/
/*										*/
/*	Private Storage 							*/
/*										*/
/********************************************************************************/

private File		patch_directory;
private String		process_id;
private MintControl	mint_control;

private CinderManager	cinder_manager;
private String			class_path;
private String			boot_path;
private CinderPatchType 	patch_type;
private Map<String,ClassType>	package_map;
private Map<String,ClassType>	class_map;
private HashSet<String> known_classes;
private long		last_command;
private Timer		dypatch_timer;
private DypatchInstrumenter dypatch_instrumenter;
private DypatchModel	patch_model;

private Map<String,DypatchModel> patch_models;

private static int	debug_flag = 0;
private static boolean	test_flag = false;



/********************************************************************************/
/*										*/
/*	Constructors								*/
/*										*/
/********************************************************************************/

private DypatchMain(String [] args)
{
   process_id = null;
   patch_directory = new File(DYPER_PATCH_DIRECTORY);
   if (!patch_directory.exists()) patch_directory.mkdirs();
   mint_control = null;
   patch_models = new HashMap<String,DypatchModel>();
   last_command = System.currentTimeMillis();

   scanArgs(args);

   class_path = null;
   boot_path = null;

   cinder_manager = new CinderManager();

   cinder_manager.setPatchFilter(this);

   patch_type = new CinderPatchType();
   patch_type.setPatchBasicBlocks(true);
   patch_type.setPatchEntry(true,0);
   patch_type.setPatchExit(true,false);
   patch_type.setPatchAllocs(true);
   patch_type.setPatchSynchronization(true);
   patch_type.setPatchWrites(false);
   patch_type.setPatchCalls(false);

   dypatch_instrumenter = new DypatchInstrumenter();
   patch_type.setInstrumenter(dypatch_instrumenter);
   cinder_manager.setPatchType(patch_type);
   patch_model = null;

   package_map = new HashMap<String,ClassType>();
   class_map = new HashMap<String,ClassType>();
   known_classes = new HashSet<String>();

   if (debug_flag == 1) {
      class_path = System.getProperty("java.class.path");
      boot_path = CinderManager.computeBasePath();
      cinder_manager.clear();
      CinderManager.setClassPath(boot_path,class_path);
      if (!CinderManager.checkIfClassExists("java.lang.management.LockInfo")) {
	 System.err.println("LockInfo doesn't exist");
       }
      System.exit(0);
    }

   dypatch_timer = new Timer("DypatchExitTimer");
   setupExit();

   BT_Class.keepConstantPool = true;
}





/********************************************************************************/
/*										*/
/*	Argument processing							*/
/*										*/
/********************************************************************************/

private void scanArgs(String [] args)
{
   for (int i = 0; i < args.length; ++i) {
      if (args[i].startsWith("-")) {
	 if (args[i].startsWith("-X")) {                                // -X  (debug)
	    ++debug_flag;
	  }
	 else if (args[i].startsWith("-T")) {
	    test_flag = true;
	  }
	 else if (args[i].startsWith("-d") && i+1 < args.length) {      // -d <directory>
	    patch_directory = new File(args[++i]);
	  }
	 else if (args[i].startsWith("-P") && i+1 < args.length) {      // -P <processid>
	    process_id = args[++i];
	  }
	 else badArgs();
       }
      else badArgs();
    }

   if (process_id == null) badArgs();
}



private void badArgs()
{
   System.err.println("DYPATCH: dypatch -P <master> [-d <directory>]");
   System.exit(1);
}




/********************************************************************************/
/*										*/
/*	Processing methods							*/
/*										*/
/********************************************************************************/

private void process()
{
   mint_control = MintControl.create(DYPER_MESSAGE_BUS,MINT_SYNC_SINGLE);

   mint_control.register("<DYPATCH PID='" + process_id + "' COMMAND='_VAR_0'><_VAR_1/></DYPATCH>",
			    new PatchCommand());
}



/********************************************************************************/
/*										*/
/*	Message routines							*/
/*										*/
/********************************************************************************/

void sendDyperMessage(String cmd,String body,MintReply hdlr,int flags)
{
   String s= "<DYPER PID='" + process_id + "'";
   if (cmd != null) s += " COMMAND='" + cmd + "'";
   s += ">";
   if (body != null) s += body;
   s += "</DYPER>";

   if (mint_control != null) {
      if (hdlr == null) mint_control.send(s);
      else mint_control.send(s,hdlr,flags);
    }
   else {
      System.err.println("DYPER: MINT MESSAGE: " + s);
    }
}



void sendReply(MintMessage msg,String r)
{
   String s = "<DYPATCH_REPLY ID='" + process_id + "'>";
   if (r != null) s += r;
   s += "</DYPATCH_REPLY>";

   msg.replyTo(s);
}



/********************************************************************************/
/*										*/
/*	Access methods								*/
/*										*/
/********************************************************************************/

String getProcessId()				{ return process_id; }

Set<BT_Class> getAllClassSet()			{ return cinder_manager.getAllClassSet(); }

BT_Class processClass(String nm,OutputStream ots)
{
   return cinder_manager.processClass(nm,ots);
}



/********************************************************************************/
/*										*/
/*	File output methods							*/
/*										*/
/********************************************************************************/

File newOutputFile()
{
   File f = null;

   try {
      f = File.createTempFile("dypatch",".class",patch_directory);
    }
   catch (IOException e) {
      System.err.println("DYPATCH: Problem creating temp file: " + e);
      return null;
    }

   f.deleteOnExit();

   return f;
}



File newOutputFile(byte [] data)
{
   File f = newOutputFile();
   if (f == null) return null;

   try {
      FileOutputStream fos = new FileOutputStream(f);
      fos.write(data);
      fos.close();
    }
   catch (IOException e) {
      System.err.println("DYPATCH: Problem outputing temp file: " + e);
      f = null;
    }

   return f;
}




/********************************************************************************/
/*										*/
/*	Cinder/patching setup methods						*/
/*										*/
/********************************************************************************/

void setupClassModel()
{
   MintDefaultReply mdr = new MintDefaultReply();
   sendDyperMessage("GETCLASSES",null,mdr,MINT_MSG_FIRST_NON_NULL);
   Element e = mdr.waitForXml();
   if (e == null) {
      System.err.println("DYPATCH: dyper process didn't respond for getclasses");
      System.exit(0);
    }

   e = IvyXml.getElementByTag(e,"CLASSES");
   setupSystemClasses(e);

   mdr = new MintDefaultReply();
   sendDyperMessage("CLASSMODEL",null,mdr,MINT_MSG_FIRST_NON_NULL);
   e = mdr.waitForXml();
   if (e == null) {
      System.err.println("DYPATCH: dyper process didn't respond for classmodel");
      System.exit(0);
    }

   e = IvyXml.getElementByTag(e,"CLASSMODEL");
   setupClasses(e);
}




private void setupSystemClasses(Element e)
{
   package_map.clear();
   class_map.clear();

   for (Element p : IvyXml.elementsByTag(e,"PACKAGE")) {
      String nm = IvyXml.getAttrString(p,"NAME");
      ClassType typ = IvyXml.getAttrEnum(p,"TYPE",ClassType.NORMAL);
      package_map.put(nm,typ);
    }
   for (Element p : IvyXml.elementsByTag(e,"CLASS")) {
      String nm = IvyXml.getAttrString(p,"NAME");
      ClassType typ = IvyXml.getAttrEnum(p,"TYPE",ClassType.NORMAL);
      class_map.put(nm,typ);
    }
}



private void setupClasses(Element xml)
{
   class_path = IvyXml.getTextElement(xml,"CLASSPATH");
   boot_path = IvyXml.getTextElement(xml,"BOOTPATH");
   String cwd = IvyXml.getTextElement(xml,"CWD");
   if (cwd != null) {
      class_path = fixupPaths(cwd,class_path);
      boot_path = fixupPaths(cwd,boot_path);
    }

   String cp = class_path + File.pathSeparator + DYPER_PATCH_JAR;

   cinder_manager.clear();
   CinderManager.setClassPath(boot_path,cp);
   System.err.println("DYPATCH: Set boot path: " + boot_path);
   System.err.println("DYPATCH: Set class path: " + cp);

   for (Element ce : IvyXml.elementsByTag(xml,"CLASS")) {
      String nm = IvyXml.getAttrString(ce,"NAME");
      known_classes.add(nm);
      byte [] data = IvyXml.getBytesElement(ce,"BINARY");
      String cldr = IvyXml.getAttrString(ce,"LOADER");
      // save class data in hierarchy based on loader
    }

   for (Element ce : IvyXml.elementsByTag(xml,"CLASS")) {
      String nm = IvyXml.getAttrString(ce,"NAME");
      known_classes.add(nm);
      String cldr = IvyXml.getAttrString(ce,"LOADER");
      // set classpath, etc based on loader
      if (!CinderManager.checkIfClassExists(nm)) {
	 System.err.println("DYPATCH: Can't find class " + nm);
       }
    }
}



String getClassFile(BT_Class bc)
{
   return cinder_manager.getClassFile(bc);
}


boolean isClassKnown(String nm)
{
   return known_classes.contains(nm);
}



private String handleSetupCommand(Element xml)
{
   if (xml == null) return null;

   String nm = IvyXml.getAttrString(xml,"MODEL");
   if (nm == null) nm = "*DEFAULT*";

   DypatchModel dm = patch_models.get(nm);
   if (dm == null) {
      dm = new DypatchModel(this);
      patch_models.put(nm,dm);
    }

   dm.resetModel();

   dm.updateModel(xml);

   String rslt = dm.handlePatchRequest(xml);

   dm.resetModel();

   return rslt;
}




/********************************************************************************/
/*										*/
/*	Cinder interface							*/
/*										*/
/********************************************************************************/

public boolean isProjectClass(String cls,Object file,boolean fg)
{
   ClassType ct = class_map.get(cls);
   if (ct == null) {
      int len = 0;
      ct = ClassType.NORMAL;
      for (Map.Entry<String,ClassType> ent : package_map.entrySet()) {
	 String pn = ent.getKey();
	 if (pn.length() > len && cls.startsWith(pn)) {
	    ct = ent.getValue();
	    len = pn.length();
	  }
       }
      class_map.put(cls,ct);
    }

   // return ct == ClassType.NORMAL;

   return true; 		// allow anything to be patched
}





/********************************************************************************/
/*										*/
/*	Message handler for commands from the DYPATCH				*/
/*										*/
/********************************************************************************/

private class PatchCommand implements MintHandler {

   PatchCommand() { }

   public void receive(MintMessage msg,MintArguments args) {
      String cmd = args.getArgument(0);
      String rslt = null;

      System.err.println("DYPATCH: Process command " + cmd);

      last_command = System.currentTimeMillis();

      if (cmd == null) return;
      else if (cmd.equals("PING")) {
	 rslt = "PONG";
       }
      else if (cmd.equals("MODEL")) {
	 handleModelCommand(args.getXmlArgument(1));
       }
      else if (cmd.equals("PATCH")) {
	 rslt = handlePatchCommand(args.getXmlArgument(1));
       }
      else if (cmd.equals("SETUP")) {
	 rslt = handleSetupCommand(args.getXmlArgument(1));
       }
      else if (cmd.equals("DIRECTORY")) {
	 patch_directory = new File(args.getArgument(1));
       }
      System.err.println("DYPATCH: Send reply: " + rslt);
      sendReply(msg,rslt);
    }

}	// end of subclass MasterCommand



/********************************************************************************/
/*										*/
/*	Exit handling methods							*/
/*										*/
/********************************************************************************/

private void setupExit()
{
   dypatch_timer.schedule(new CheckExit(),EXIT_DELAY);
}


private void checkExit()
{
   MintDefaultReply mdr = new MintDefaultReply();
   sendDyperMessage("PING",null,mdr,MINT_MSG_FIRST_REPLY);
   String msg = mdr.waitForString(15000);
   if (msg != null) last_command = System.currentTimeMillis();

   long now = System.currentTimeMillis();
   if (now - last_command < EXIT_DELAY) {
      dypatch_timer.schedule(new CheckExit(),EXIT_DELAY);
    }
   else {
      System.err.println("DYPATCH: Exiting due to timeout");
      System.exit(0);
    }
}



private class CheckExit extends TimerTask {

   public void run() {
      checkExit();
    }

}	// end of subclass CheckExit



/********************************************************************************/
/*										*/
/*	Testing methods 							*/
/*										*/
/********************************************************************************/

private void test()
{
   CinderManager.do_debug = true;

   String m1 = "<SETUP NAME='SOCKETAGENT'>" +
      "<FOR CLASS='java.net.Socket' METHOD='close'>" +
      "<PATCH WHAT='ENTER' MODE='SOCKETAGENT_CLOSE1' /></FOR>" +
      "<CLASS NAME='java.net.Socket' /> </SETUP>";

   Element e = IvyXml.convertStringToXml(m1);
   System.err.println("COMMAND = " + IvyXml.convertXmlToString(e));
   String rslt = handleSetupCommand(e);
   System.err.println("RESULT = " + rslt);
}




}	// end of class DypatchMain




/* end of DypatchMain.java */




